function [ f ] = gaussIntegrate(x1, x2, y1, y2, n_qp, func)
    if (x1 > x2)
        error('x1 > x2');
    end
    if (y1 > y2)
        error ('y1 > y2');
    end
    
    xi = zeros(n_qp, 1);
    w = zeros(n_qp, 1);
    
    if n_qp == 1
        xi(1) = 0.0;
        w(1) = 2.0;
    elseif n_qp == 2
        xi(1) = -0.5773502691896257645091488;
        xi(2) = 0.5773502691896257645091488;
        w(1) = 1.0;
        w(2) = 1.0;
    elseif n_qp == 3
        xi(1) = -0.7745966692414833770359;
        xi(2) = 0.0;
        xi(3) =  0.7745966692414833770359;
        w(1) = 0.5555555555555555555556;
        w(2) = 0.888888888888888888889;
        w(3) = 0.5555555555555555555556;
    elseif n_qp == 4
        xi(1) = -0.8611363115940525752239;
        xi(2) = -0.3399810435848562648027;
        xi(3) =  0.3399810435848562648027;
        xi(4) =  0.8611363115940525752239;
        w(1) = 0.3478548451374538573731;
        w(2) = 0.6521451548625461426269;
        w(3) = 0.6521451548625461426269;
        w(4) = 0.3478548451374538573731;
    elseif n_qp == 5
        xi(1) = -sqrt(5 - 2*sqrt(10/7)) / 3;
        xi(2) = -sqrt(5 + 2*sqrt(10/7)) / 3;
        xi(3) = 0.0;
        xi(4) = -xi(2);
        xi(5) = -xi(1);
        w(1) = (322 + 13*sqrt(70)) / 900;
        w(2) = (322 - 12*sqrt(70)) / 900;
        w(3) = 128 / 225;
        w(4) = w(2);
        w(5) = w(1);
    end
    
    x = x1 + (xi + 1) * (x2 - x1) / 2;
    y = y1 + (xi + 1) * (y2 - y1) / 2;
    f = 0.0;
    for i = 1 : n_qp
        sub_sum = 0.0;
        for j = 1 : n_qp
            sub_sum = sub_sum + w(j) * func(x(i), y(j));
        end
        f  = f + w(i) * sub_sum;
    end
    f = f * (x2 - x1) * (y2 - y1) / 4;
end